<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HelperService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mosip-identity-plugin</a> &gt; <a href="index.source.html" class="el_package">io.mosip.esignet.plugin.ida.service</a> &gt; <span class="el_source">HelperService.java</span></div><h1>HelperService.java</h1><pre class="source lang-java linenums">/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
package io.mosip.esignet.plugin.ida.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.mosip.esignet.plugin.ida.dto.IdaKycAuthRequest;
import io.mosip.esignet.plugin.ida.dto.IdaSendOtpRequest;
import io.mosip.esignet.plugin.ida.dto.IdaSendOtpResponse;
import io.mosip.esignet.plugin.ida.dto.KeyBindedToken;
import io.mosip.esignet.api.dto.AuthChallenge;
import io.mosip.esignet.api.dto.SendOtpResult;
import io.mosip.esignet.api.exception.KycAuthException;
import io.mosip.esignet.api.exception.SendOtpException;
import io.mosip.kernel.core.util.CryptoUtil;
import io.mosip.kernel.core.util.HMACUtils2;
import io.mosip.kernel.crypto.jce.core.CryptoCore;
import io.mosip.kernel.keygenerator.bouncycastle.util.KeyGeneratorUtils;
import io.mosip.kernel.keymanagerservice.util.KeymanagerUtil;
import io.mosip.kernel.partnercertservice.util.PartnerCertificateManagerUtil;
import io.mosip.kernel.signature.dto.JWTSignatureRequestDto;
import io.mosip.kernel.signature.dto.JWTSignatureResponseDto;
import io.mosip.kernel.signature.service.SignatureService;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.lang3.NotImplementedException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.MediaType;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.X509Certificate;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;

@Service
<span class="fc" id="L59">@Slf4j</span>
<span class="fc" id="L60">public class HelperService {</span>

    public static final String CHARACTERS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;;
    public static final String SIGNATURE_HEADER_NAME = &quot;signature&quot;;
    public static final String AUTHORIZATION_HEADER_NAME = &quot;Authorization&quot;;
    public static final String UTC_DATETIME_PATTERN = &quot;yyyy-MM-dd'T'HH:mm:ss.SSS'Z'&quot;;
    public static final String INVALID_PARTNER_CERTIFICATE = &quot;invalid_partner_cert&quot;;
    public static final String OIDC_PARTNER_APP_ID = &quot;OIDC_PARTNER&quot;;
    public static final String BINDING_TRANSACTION = &quot;bindingtransaction&quot;;
    private static Base64.Encoder urlSafeEncoder;
    private static Base64.Decoder urlSafeDecoder;
    private static SecureRandom secureRandom;

    static {
<span class="fc" id="L74">        urlSafeEncoder = Base64.getUrlEncoder().withoutPadding();</span>
<span class="fc" id="L75">        urlSafeDecoder = Base64.getUrlDecoder();</span>
<span class="fc" id="L76">        secureRandom = new SecureRandom();</span>
<span class="fc" id="L77">    }</span>

    @Value(&quot;${mosip.esignet.authenticator.ida-send-otp-id:mosip.identity.otp}&quot;)
    private String sendOtpId;

    @Value(&quot;${mosip.esignet.authenticator.ida-send-otp-version:1.0}&quot;)
    private String idaVersion;

    @Value(&quot;${mosip.esignet.authenticator.ida.cert-url}&quot;)
    private String idaPartnerCertificateUrl;

    @Value(&quot;${mosip.esignet.authenticator.ida.send-otp-url}&quot;)
    private String sendOtpUrl;

    @Value(&quot;${mosip.kernel.keygenerator.symmetric-algorithm-name}&quot;)
    private String symmetricAlgorithm;

    @Value(&quot;${mosip.kernel.keygenerator.symmetric-key-length}&quot;)
    private int symmetricKeyLength;

    @Autowired
    private KeymanagerUtil keymanagerUtil;

    @Autowired
    private SignatureService signatureService;

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private CryptoCore cryptoCore;

    private Certificate idaPartnerCertificate;

    @Cacheable(value = BINDING_TRANSACTION, key = &quot;#idHash&quot;)
    public String getTransactionId(String idHash) {
<span class="nc" id="L116">        return HelperService.generateTransactionId(10);</span>
    }

    protected void setAuthRequest(List&lt;AuthChallenge&gt; challengeList, IdaKycAuthRequest idaKycAuthRequest) throws Exception {
<span class="fc" id="L120">        IdaKycAuthRequest.AuthRequest authRequest = new IdaKycAuthRequest.AuthRequest();</span>
<span class="fc" id="L121">        authRequest.setTimestamp(HelperService.getUTCDateTime());</span>
<span class="fc" id="L122">        challengeList.stream()</span>
<span class="pc bpc" id="L123" title="2 of 4 branches missed.">                .filter( auth -&gt; auth != null &amp;&amp;  auth.getAuthFactorType() != null)</span>
<span class="fc" id="L124">                .forEach( auth -&gt; { buildAuthRequest(auth, authRequest); });</span>

<span class="fc" id="L126">        KeyGenerator keyGenerator = KeyGeneratorUtils.getKeyGenerator(symmetricAlgorithm, symmetricKeyLength);</span>
<span class="fc" id="L127">        final SecretKey symmetricKey = keyGenerator.generateKey();</span>
<span class="fc" id="L128">        String request = objectMapper.writeValueAsString(authRequest);</span>
<span class="fc" id="L129">        String hexEncodedHash = HMACUtils2.digestAsPlainText(request.getBytes(StandardCharsets.UTF_8));</span>
<span class="fc" id="L130">        idaKycAuthRequest.setRequest(HelperService.b64Encode(CryptoUtil.symmetricEncrypt(symmetricKey,</span>
<span class="fc" id="L131">                request.getBytes(StandardCharsets.UTF_8))));</span>
<span class="fc" id="L132">        idaKycAuthRequest.setRequestHMAC(HelperService.b64Encode(CryptoUtil.symmetricEncrypt(symmetricKey,</span>
<span class="fc" id="L133">                hexEncodedHash.getBytes(StandardCharsets.UTF_8))));</span>
<span class="fc" id="L134">        Certificate certificate = getIdaPartnerCertificate();</span>
<span class="fc" id="L135">        idaKycAuthRequest.setThumbprint(HelperService.b64Encode(getCertificateThumbprint(certificate)));</span>
<span class="fc" id="L136">        log.info(&quot;IDA certificate thumbprint {}&quot;, idaKycAuthRequest.getThumbprint());</span>
<span class="fc" id="L137">        idaKycAuthRequest.setRequestSessionKey(HelperService.b64Encode(</span>
<span class="fc" id="L138">                cryptoCore.asymmetricEncrypt(certificate.getPublicKey(), symmetricKey.getEncoded())));</span>
<span class="fc" id="L139">    }</span>


    protected SendOtpResult sendOTP(String partnerId, String clientId, IdaSendOtpRequest idaSendOtpRequest)
            throws SendOtpException, JsonProcessingException {
<span class="fc" id="L144">        idaSendOtpRequest.setId(sendOtpId);</span>
<span class="fc" id="L145">        idaSendOtpRequest.setVersion(idaVersion);</span>
<span class="fc" id="L146">        idaSendOtpRequest.setRequestTime(getUTCDateTime());</span>

        //set signature header, body and invoke kyc exchange endpoint
<span class="fc" id="L149">        String requestBody = objectMapper.writeValueAsString(idaSendOtpRequest);</span>
<span class="fc" id="L150">        RequestEntity requestEntity = RequestEntity</span>
<span class="fc" id="L151">                .post(UriComponentsBuilder.fromUriString(sendOtpUrl).pathSegment(partnerId, clientId).build().toUri())</span>
<span class="fc" id="L152">                .contentType(MediaType.APPLICATION_JSON_UTF8)</span>
<span class="fc" id="L153">                .header(SIGNATURE_HEADER_NAME, getRequestSignature(requestBody))</span>
<span class="fc" id="L154">                .header(AUTHORIZATION_HEADER_NAME, AUTHORIZATION_HEADER_NAME)</span>
<span class="fc" id="L155">                .body(requestBody);</span>
<span class="fc" id="L156">        ResponseEntity&lt;IdaSendOtpResponse&gt; responseEntity = restTemplate.exchange(requestEntity, IdaSendOtpResponse.class);</span>
<span class="pc bpc" id="L157" title="1 of 4 branches missed.">        if(responseEntity.getStatusCode().is2xxSuccessful() &amp;&amp; responseEntity.getBody() != null) {</span>
<span class="fc" id="L158">            IdaSendOtpResponse idaSendOtpResponse = responseEntity.getBody();</span>
<span class="pc bpc" id="L159" title="1 of 4 branches missed.">            if(idaSendOtpRequest.getTransactionID().equals(idaSendOtpResponse.getTransactionID()) &amp;&amp; idaSendOtpResponse.getResponse() != null){</span>
<span class="fc" id="L160">                return new SendOtpResult(idaSendOtpResponse.getTransactionID(),</span>
<span class="fc" id="L161">                        idaSendOtpResponse.getResponse().getMaskedEmail(),</span>
<span class="fc" id="L162">                        idaSendOtpResponse.getResponse().getMaskedMobile());</span>
            }
<span class="fc" id="L164">            log.error(&quot;Errors in response received from IDA send-otp : {}&quot;, idaSendOtpResponse.getErrors());</span>
<span class="fc" id="L165">            throw new SendOtpException(idaSendOtpResponse.getErrors().get(0).getErrorCode());</span>
        }
<span class="fc" id="L167">        log.error(&quot;Error response received from IDA (send-otp) with status : {}&quot;, responseEntity.getStatusCode());</span>
<span class="fc" id="L168">        throw new SendOtpException();</span>
    }

    protected String getRequestSignature(String request) {
<span class="fc" id="L172">        JWTSignatureRequestDto jwtSignatureRequestDto = new JWTSignatureRequestDto();</span>
<span class="fc" id="L173">        jwtSignatureRequestDto.setApplicationId(OIDC_PARTNER_APP_ID);</span>
<span class="fc" id="L174">        jwtSignatureRequestDto.setReferenceId(&quot;&quot;);</span>
<span class="fc" id="L175">        jwtSignatureRequestDto.setIncludePayload(false);</span>
<span class="fc" id="L176">        jwtSignatureRequestDto.setIncludeCertificate(true);</span>
<span class="fc" id="L177">        jwtSignatureRequestDto.setDataToSign(HelperService.b64Encode(request));</span>
<span class="fc" id="L178">        JWTSignatureResponseDto responseDto = signatureService.jwtSign(jwtSignatureRequestDto);</span>
<span class="fc" id="L179">        log.debug(&quot;Request signature ---&gt; {}&quot;, responseDto.getJwtSignedData());</span>
<span class="fc" id="L180">        return responseDto.getJwtSignedData();</span>
    }

    protected Certificate getIdaPartnerCertificate() throws KycAuthException {
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if(StringUtils.isEmpty(idaPartnerCertificate)) {</span>
<span class="fc" id="L185">            log.info(&quot;Fetching IDA partner certificate from : {}&quot;, idaPartnerCertificateUrl);</span>
<span class="fc" id="L186">            idaPartnerCertificate = keymanagerUtil.convertToCertificate(restTemplate.getForObject(idaPartnerCertificateUrl,</span>
                    String.class));
        }
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if(PartnerCertificateManagerUtil.isCertificateDatesValid((X509Certificate)idaPartnerCertificate))</span>
<span class="fc" id="L190">            return idaPartnerCertificate;</span>

<span class="fc" id="L192">        log.info(&quot;PARTNER CERTIFICATE IS NOT VALID, Downloading the certificate again&quot;);</span>
<span class="fc" id="L193">        idaPartnerCertificate = keymanagerUtil.convertToCertificate(restTemplate.getForObject(idaPartnerCertificateUrl,</span>
                String.class));
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        if(PartnerCertificateManagerUtil.isCertificateDatesValid((X509Certificate)idaPartnerCertificate))</span>
<span class="fc" id="L196">            return idaPartnerCertificate;</span>

<span class="nc" id="L198">        throw new KycAuthException(INVALID_PARTNER_CERTIFICATE);</span>
    }

    protected byte[] getCertificateThumbprint(Certificate certificate) {
        try {
<span class="fc" id="L203">            return DigestUtils.sha256(certificate.getEncoded());</span>
<span class="nc" id="L204">        } catch (CertificateEncodingException e) {</span>
<span class="nc" id="L205">            log.error(&quot;Failed to get cert thumbprint&quot;, e);</span>
        }
<span class="nc" id="L207">        return new byte[]{};</span>
    }

    /**
     * Output format : 2022-12-01T03:22:46.720Z
     * @return Formatted datetime
     */
    protected static String getUTCDateTime() {
<span class="fc" id="L215">        return ZonedDateTime</span>
<span class="fc" id="L216">                .now(ZoneOffset.UTC)</span>
<span class="fc" id="L217">                .format(DateTimeFormatter.ofPattern(UTC_DATETIME_PATTERN));</span>
    }

    protected static String b64Encode(byte[] bytes) {
<span class="fc" id="L221">        return urlSafeEncoder.encodeToString(bytes);</span>
    }

    protected static String b64Encode(String value) {
<span class="fc" id="L225">        return urlSafeEncoder.encodeToString(value.getBytes(StandardCharsets.UTF_8));</span>
    }

    protected static byte[] b64Decode(String value) {
<span class="fc" id="L229">        return urlSafeDecoder.decode(value);</span>
    }

    private void buildAuthRequest(AuthChallenge authChallenge, IdaKycAuthRequest.AuthRequest authRequest) {
<span class="fc" id="L233">        log.info(&quot;Build kyc-auth request with authFactor : {}&quot;,  authChallenge.getAuthFactorType());</span>
<span class="pc bpc" id="L234" title="1 of 6 branches missed.">        switch (authChallenge.getAuthFactorType().toUpperCase()) {</span>
<span class="fc" id="L235">            case &quot;OTP&quot; : authRequest.setOtp(authChallenge.getChallenge());</span>
<span class="fc" id="L236">                break;</span>
<span class="fc" id="L237">            case &quot;PIN&quot; : authRequest.setStaticPin(authChallenge.getChallenge());</span>
<span class="fc" id="L238">                break;</span>
            case &quot;BIO&quot; :
<span class="fc" id="L240">                byte[] decodedBio = HelperService.b64Decode(authChallenge.getChallenge());</span>
                try {
<span class="fc" id="L242">                    List&lt;IdaKycAuthRequest.Biometric&gt; biometrics = objectMapper.readValue(decodedBio,</span>
<span class="fc" id="L243">                            new TypeReference&lt;List&lt;IdaKycAuthRequest.Biometric&gt;&gt;(){});</span>
<span class="fc" id="L244">                    authRequest.setBiometrics(biometrics);</span>
<span class="nc" id="L245">                } catch (Exception e) {</span>
<span class="nc" id="L246">                    log.error(&quot;Failed to parse biometric capture response&quot;, e);</span>
<span class="fc" id="L247">                }</span>
<span class="nc" id="L248">                break;</span>
            case &quot;WLA&quot; :
<span class="nc" id="L250">                List&lt;KeyBindedToken&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L251">                KeyBindedToken keyBindedToken = new KeyBindedToken();</span>
<span class="nc" id="L252">                keyBindedToken.setType(authChallenge.getAuthFactorType());</span>
<span class="nc" id="L253">                keyBindedToken.setToken(authChallenge.getChallenge());</span>
<span class="nc" id="L254">                keyBindedToken.setFormat(authChallenge.getFormat());</span>
<span class="nc" id="L255">                list.add(keyBindedToken);</span>
<span class="nc" id="L256">                authRequest.setKeyBindedTokens(list);</span>
<span class="nc" id="L257">                break;</span>
<span class="fc" id="L258">            case &quot;PWD&quot; : authRequest.setPassword(authChallenge.getChallenge());</span>
<span class="fc" id="L259">                break;</span>
            default:
<span class="fc" id="L261">                throw new NotImplementedException(&quot;KYC auth not implemented&quot;);</span>
        }
<span class="fc" id="L263">    }</span>

    protected static String generateTransactionId(int length) {
<span class="nc" id="L266">        StringBuilder builder = new StringBuilder();</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">        for(int i=0; i&lt;length; i++) {</span>
<span class="nc" id="L268">            int index = secureRandom.nextInt(CHARACTERS.length());</span>
<span class="nc" id="L269">            builder.append(CHARACTERS.charAt(index));</span>
        }
<span class="nc" id="L271">        return builder.toString();</span>
    }

    protected static String generateHash(String value) {
        try {
<span class="fc" id="L276">            MessageDigest digest = MessageDigest.getInstance(&quot;SHA3-256&quot;);</span>
<span class="fc" id="L277">            byte[] hash = digest.digest(value.getBytes(StandardCharsets.UTF_8));</span>
<span class="fc" id="L278">            return urlSafeEncoder.encodeToString(hash);</span>
<span class="nc" id="L279">        } catch (NoSuchAlgorithmException ex) {</span>
<span class="nc" id="L280">            log.error(&quot;Hashing failed&quot;, ex);</span>
        }
<span class="nc" id="L282">        return value;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>